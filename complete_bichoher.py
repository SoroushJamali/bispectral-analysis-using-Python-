# -*- coding: utf-8 -*-
"""COMPLETE Bichoher.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1C1avva0wjZm9yoN2JP9iaREvfp5T7u97

# **Libereires**
"""

import sklearn  
from sklearn import preprocessing
import IPython.display as ipd
import scipy  
from scipy.stats import norm, kurtosis
from scipy.linalg import hankel
from scipy.fft import fft,fftshift
from scipy.stats import skew
from scipy import signal

import librosa, librosa.display
import numpy as np
import statistics
import math

import matplotlib.pyplot as plt
from pathlib import Path

"""# **# Usefull Functions**"""

all_true_var_ang = [0,0,0,0]
all_true_var_bic = [0,0,0,0]
all_true_std_ang = [0,0,0,0]
all_true_std_bic = [0,0,0,0]
all_true_skew_ang = [0,0,0,0]
all_true_skew_bic = [0,0,0,0]
all_true_kurtosis_ang = [0,0,0,0]
all_true_kurtosis_bic = [0,0,0,0]

all_fake_var_ang = [0,0,0,0]
all_fake_var_bic = [0,0,0,0]
all_fake_std_ang = [0,0,0,0]
all_fake_std_bic = [0,0,0,0]
all_fake_skew_ang = [0,0,0,0]
all_fake_skew_bic = [0,0,0,0]
all_fake_kurtosis_ang = [0,0,0,0]
all_fake_kurtosis_bic = [0,0,0,0]

def next_power_of_2(x):
    return 1 if x == 0 else 2**math.ceil(math.log2(x))

def normalizer(data):
  oldmin = min(data)
  oldmax = max(data)
  oldrange = oldmax - oldmin
  newmin = 0.
  newmax = 1.
  newrange = newmax - newmin
  if oldrange == 0:            # Deal with the case where rvalue is constant:
      if oldmin < newmin:      # If rvalue < newmin, set all rvalue values to newmin
         newval = newmin
      elif oldmin > newmax:    # If rvalue > newmax, set all rvalue values to newmax
          newval = newmax
      else:                    # If newmin <= rvalue <= newmax, keep rvalue the same
          newval = oldmin
      normal = [newval for v in data]
  else:
       scale = newrange / oldrange
       normal = [(v - oldmin) * scale + newmin for v in data]

  return normal

"""# **Bicoherence**"""

#	[bic,waxis] = bicoher (y,  nfft, wind, segsamp, overlap)
#	y     - data vector or time-series
#	nfft - fft length [default = power of two > segsamp]
#	       actual size used is power of two greater than 'nsamp'
#	wind - specifies the time-domain window to be applied to each
#	       data segment; should be of length 'segsamp' (see below);
#		otherwise, the default Hanning window is used.
#	segsamp - samples per segment [default: such that we have 8 segments]
#	        - if x is a matrix, segsamp is set to the number of rows
#	overlap - percentage overlap, allowed range [0,99]. [default = 50];
#	        - if x is a matrix, overlap is set to 0.
#	bic     - estimated bicoherence: an nfft x nfft array, with origin
#	          at the center, and axes pointing down and to the right.
#	waxis   - vector of frequencies associated with the rows and columns
#	          of bic;  sampling frequency is assumed to be 1.
def bicoher(y,  nfft, winds, nsamp, overlap,normalization):

#--------------------parameter checks---------------------
  means = [0,0]
  ly = len(y)
  nrecs = 1
  if (ly == 1):
    y = (np.array(y)).reshape((-1, 1)) 
    ly = nrecs; 
    nrecs = 1;

  if nfft is None:
    nfft = 128

  if overlap is None:
    overlap = 50
  overlap = max(0,min(overlap,99))

  if nrecs > 1:  
    overlap = 0
  if nrecs > 1 :
    nsamp = ly
 
  if nrecs == 1 and nsamp <= 0:
    nsamp = np.fix(ly/ (8 - 7 * overlap/100))
  if nfft  < nsamp:
     nfft = 2^next_power_of_2(nsamp)

 
  overlap  = int(np.fix( nsamp * overlap/100))
  
  nadvance = nsamp - overlap
  nrecs    = int(np.fix ( (ly*nrecs - overlap) / nadvance))
  if winds is None:
     wind = np.hanning(nsamp)

  if winds == 'hann':
    wind = scipy.signal.hann(nsamp)
  elif winds == 'hamm':
    wind = scipy.signal.hamming(nsamp)
   

  rw = len(wind)
  cw = 1

  if min(rw,cw) != 1 or max(rw,cw) != nsamp:
	   print(['Segment size  is ',str(nsamp)])
	   print(['"wind" array  is ',str(rw),' by ',str(cw)])
	   print(['Using default Hanning window'])
	   wind = np.hanning(nsamp);
  

#---------------- accumulate triple products ----------------------
  bic  = np.zeros((nfft,nfft))
  Pyy  = np.zeros((1,nfft))
  Yf12 = np.zeros((nfft,nfft))
  ind  = np.array(np.arange(0,nsamp))

  for i in range(0, nrecs):
    ys = y[ind[0]:ind[-1]+1]
    ys = (ys- np.mean(ys))*wind
    Yf = np.array(fft(ys,nfft))/ nsamp
    CYf = np.conjugate(Yf)
    Pyy = Pyy + Yf * CYf
    CYf_shi = np.roll(CYf,1)
    Yf12 = hankel(CYf,CYf_shi)
    bic = bic + (Yf * Yf.reshape((-1, 1))) * Yf12
    ind = ind + nadvance
    
 
  bicc     = bic / nrecs
  angles=(sum(np.angle(bicc)))
  means[0] = np.mean(angles)
  X_mag,X_phase=librosa.magphase(fftshift(bicc)) 
  Pyy     = Pyy  / nrecs
  Pyy_shi = np.roll(Pyy,1)
  mask = hankel(Pyy,Pyy_shi)
    
  if normalization==1 : # -------- Defualt
    den = (Pyy * Pyy.reshape((-1, 1))*mask) 
    bic = abs(bicc)**2 /abs(den) 

  elif normalization == 2: #---------- papre
    den = (abs(Pyy * Pyy.reshape((-1, 1)))**2 * abs(mask)**2) 
    bic = (bicc) / np.sqrt(den) 

  elif normalization == 3:  # -------- 1 wiki
    den = pow(abs(Pyy),2) * pow(abs(Pyy.reshape((-1, 1))),2) * abs(mask)**2
    denn = pow(den,-2)
    bic = abs(bicc) / denn

  elif normalization == 4: # --------- 2 wiki
    den = (abs(Pyy * Pyy.reshape((-1, 1)))**2 * abs(mask)**2) 
    bic = abs(bicc)**2  / (den) 

  elif normalization == 5: # --------- 3 wiki
    den = abs(Pyy * Pyy.reshape((-1, 1)) * mask)
    bic = abs(bicc)  / (den) 
 

  biccc = fftshift(bic) 
  means[1] = np.mean(biccc)   

  var_ang  = np.var (angles)/means[1]
  var_bic  = np.var (biccc)/means[1]

  std_ang  = np.std (angles)
  std_bic  = np.std (biccc)

  skew_ang = skew(angles)
  skew_bic = skew(np.sum(biccc))

  kurtosis_ang = kurtosis(angles)
  kurtosis_bic = kurtosis(np.sum(biccc))

  statistic = [var_ang,var_bic,std_ang,std_bic,skew_ang,skew_bic,kurtosis_ang,kurtosis_bic]

  den = (Pyy * Pyy.reshape((-1, 1))*mask) 
  bic = abs(bicc)**2 /abs(den)
  means[1] = np.mean(bic)
  biccc = fftshift(bic) 

  return angles,bic,means,statistic

"""# X^2 **Nonlinearity**

# **Signal generation**
"""

fs = 44100
N = 1e4
time = np.arange(N) / float(fs)
x =  -np.sin(2*np.pi*40*time ) 
noise_volts = np.random.normal(0, .05, len(x))
x=x+noise_volts
X = x**2+x

"""# **Testing parameters**"""

# ---------------- Params
#	[bic,waxis] = bicoher (y,  nfft, wind, segsamp, overlap)

#nfft = [64, 128, 512, 1024,2048]  
#wind = ['hann', 'hamm']
#segsamp = [64,128,256,512]
#overlap  = [30,50,70]
nfft = [1024]  
wind = ['hann']
segsamp = [32]
overlap  = [50]
alpha = np.array([.1,.4,.8,1])
subn = len(alpha)+1
## ---------- Plots -----------------
subp = -1
plt.figure(figsize=(20,20))
for i in range(0, len(nfft)):
  for j in range(0, len(wind)):
    for k in range(0, len(segsamp)):
      for o in range(0, len(overlap)):
        plt.subplot(subn,3,1)
        plt.plot(x)
        plt.title('signal x')
        subp = 1 + subp
        anglez_x,bic_x,meansx,statistic_x= bicoher(x,nfft[i],wind[j],segsamp[k],overlap[o],21)
        plt.subplot(subn,3,2)
        plt.imshow(20*np.log10(abs(fftshift(bic_x))))
        plt.title('signal x with NFFT= {}'.format(nfft[i]) + ', Window= {}'.format(wind[j]) + ', segsamp= {}'.format(segsamp[k]) + ', overlap= {}'.format(overlap[o]))
        plt.subplot(subn,3,3)
        plt.hist(anglez_x,7)
        plt.subplots_adjust(hspace=0.5)
        plt.subplots_adjust(wspace=0.5)

plt.figure(figsize=(20,20))
for hhh in range(0, len(alpha)):
  for i in range(0, len(nfft)):
    for j in range(0, len(wind)):
      for k in range(0, len(segsamp)):
        for o in range(0, len(overlap)):
          X = alpha[hhh]*x**2+x
          subp=subp+3
          plt.subplot(subn,3,subp+1)
          plt.plot(X)
          plt.title('signal X with Alpha = {}'.format(alpha[hhh]))
          anglez_X,bic_x,meansX,statistic_X= bicoher(X,nfft[i],wind[j],segsamp[k],overlap[o],2)
          plt.subplot(subn,3,subp+2)
          plt.imshow(20*np.log10(abs(fftshift(bic_x))))
          plt.title('signal X with NFFT= {}'.format(nfft[i]) + ', Window= {}'.format(wind[j]) + ', segsamp= {}'.format(segsamp[k]) + ', overlap= {}'.format(overlap[o]))
          plt.subplot(subn,3,subp+3)
          plt.subplots_adjust(hspace=0.5)
          plt.subplots_adjust(wspace=0.5)
          plt.hist(anglez_X,7)

all_true_var_ang[0] = statistic_x[0]
all_true_var_bic[0] = statistic_x[1]
all_true_std_ang[0] = statistic_x[2]
all_true_std_bic[0] = statistic_x[3]
all_true_skew_ang[0] = statistic_x[4]
all_true_skew_bic[0] = statistic_x[5]
all_true_kurtosis_ang[0] = statistic_x[6]
all_true_kurtosis_bic[0] = statistic_x[7]

all_fake_var_ang[0] = statistic_X[0]
all_fake_var_bic[0] = statistic_X[1]
all_fake_std_ang[0] = statistic_X[2]
all_fake_std_bic[0] = statistic_X[3]
all_fake_skew_ang[0] = statistic_X[4]
all_fake_skew_bic[0] = statistic_X[5]
all_fake_kurtosis_ang[0] = statistic_X[6]
all_fake_kurtosis_bic[0] = statistic_X[7]

print('var_ang')
print('x = ',statistic_x[0], 'X = ',statistic_X[0])
print('var_bic')
print('x = ',statistic_x[1],  'X = ',statistic_X[1])
print('std_ang' )
print('x = ',statistic_x[2],  'X = ',statistic_X[2])
print('std_bic')
print('x = ',statistic_x[3], 'X = ',statistic_X[3])
print('skew_ang')
print('x  = ',statistic_x[4], 'X = ',statistic_X[4])
print('skew_bic')
print('x = ',statistic_x[5], 'X = ',statistic_X[5])
print('kurtosis_ang')
print('x = ',statistic_x[6], 'X = ',statistic_X[6])
print('kurtosis_bic')
print('x = ',statistic_x[7], 'X = ',statistic_X[7])

"""![2.PNG](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAe4AAACFCAYAAACdUxt7AAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAAJOgAACToAYJjBRwAABnASURBVHhe7d0J2BXTA8dxnp4n/aVSdkkRpVDWsksUoY3CoxAiax5UT7JlCZW1JKVUaKOUQguRUgmRrKlQUiR5Q7Kfv99pzph7u/d9775+P89znmrmzty5877N754zZ87ZxgDJ+mudWTBpnunRbYo5odVEU77ZllKj3WTTvNss8+Rrq8yPf3mvBQAkheAGACCPENwAAOQRghsAgDxCcAMAkEcIbgAA8gjBDQBAHiG4AQDIIwQ3AAB5hOAGACCPENwAAOQRghsAgDxCcAMAkEcIbgAA8gjBDQBAHiG4AQDIIwQ3AAB5hOAGACCPENwAAOQRghsAgDxCcAPIin/++ccvpfn777/LfA1QTAhuABmlEP7qq6/MK6+8YgYOHGhGjBhhli5dajZv3uy9YosNGzbY1/Tt29cMHTrUzJkzx/z555/eWqB4EdwAMkbB26dPH7PNNttsVY466iizaNEiG+z6s379+lu9pmPHjub333/39gYUJ4IbQEYotG+++WYbwCeccIKZNWuWWb9+vXnuuedMo0aN7HKF9fz58/3QHjt2rPnjjz/MyJEjTYcOHeyyCRMm0HSOokZwA0g73aeeOnWqDd5DDz10qybv0aNH23UqBx54oP1z8ODBdt2kSZNMtWrV/PVnnXWW3R9QrAhuAGn31ltv2dCtV69exKbukpISP5hVTjnlFBvOqm1fffXVIetUaye4UcwIbgBp9ddff9l70wpd1bojWbhwYUg4Dxs2zC5XcLdu3Tpk3bvvvmvXAcWK4AaQVr/99pupWbOmadasmQ3xSAYMGBASzup17owaNcqcffbZ9r73008/HXUfQLEguAGklYJWzduzZ8/2loRSs7fuW7vQVse1IHVE0z1x1b5pIgcIbgBZtmnTJlO9enU/uG+//XZvDYBICG4AWaVBVlxoq8ybN89bAyASghtAVt12221+aFeqVIlntIEyENwAskb3rJs2beoHd/j9bQBbI7gBpJ3rYBY+8MrKlStN+fLl/eDu2rXrVq8RbT9jxgz7KBg1chQ7ghtAWimI33jjDXPOOeeYLl262FHSHA1l6kJbRY9+RaIe5UcccYRp0aJFxGAHignBDSCtwjufaTAWF76dO3cOWff+++/b5eFefPFFu/6ZZ57hkTAUPYI7x+kCpyEis9E8qFqOCpAoPcPdvXv3kHC+6KKLbPhq2s699947ZN0333zjbfkfTffZvn17c/jhhzMzGPAvgjuHacSpa6+91l7QVNPIJF1Y9b6aalHHASRCv0fBwVV23HFH8/zzz9t1d955p7/clcWLF9t1jn73brjhBrtOA7hwfxsguNNGFyzVFFRDSGTEJ9W03RSIGrc53u1TQZ2BypUrZy+2hDcSoaB9/PHH7e+xeozPnTvXDmfar18/u6xJkyZmxIgR9u8qt9xyi/2902s03ae20fLHHnuMoU4BD8GdBgprXZiaN29uLzoaZ1ljLMfa7BwMbTUzZqszji66vXv3tsehWhPNlEjE2rVrzZFHHml/j4Ll4IMPNl9//bX9/db/j/D1KjvssIMZOHAgoQ0EENwpppqpgloXHU2soCkJGzdubP99wQUXlBneukD16tXLvv7000/P+j1mHc+pp55qj0chnq0vEchv+tKncL788svt/Wr1LP/uu++8tVt+z5YuXWpbl9q2bWsuu+wyM2jQIDtrGM3jQCiCO4UUsu5+XsWKFc2SJUu2qkksW7bMe3Vk48eP918bbQrETNNcylWqVLHHpItpNprtURj0u1Pa749CWl8O+R0DoiO4U+jBBx/0Q1dzCGvyhFq1avnLVBYsWOC9emuqrR977LH2deeee25O1W6DPYMV5ACA7CC4U0Qh27JlSz/cNMORnkl1/1bRfMIlJSXeFltzHXZUNGBFLlHrgRvh6sorr+SeIwBkCcGdIuoFu/322/vBq56xuq/nesVeeumlNvyi3a9TJ5299trLvrZDhw452VSo5291fO42AAAg8wjuFFGnGhfaKr/88otdrvveagIvrZOZwvyhhx7yt508ebK3JrcER8C68cYbqXUDQBYQ3CmgAFOPcRdqevQlnvvTCvXjjz/ebqvRoXK157ZaAU4++WR7nLvuuqv54osvvDUAgEwhuFNAQVu7dm0/uK+44oq4wlfN6m5bTcKQy7p16+Yf6+DBg72lAIBMIbhTQL3HXZipDB8+3FtTNjWTaypDt+3QoUO9NblpzJgx/rHqvj2DsgBAZhHcKTB//nw/zFQ+++wzb03ZVDM/6aST/G0///xzb01iFKTap5rvo92D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)"""

X = x / np.sqrt(1+x**2)

#nfft = [64, 128, 512, 1024,2048]  
#wind = ['hann', 'hamm']
#segsamp = [64,128,256,512]
#overlap  = [30,50,70]
nfft = [2048]  
wind = ['hann']
segsamp = [32]
overlap  = [50]
subn=2
subp=3
## ---------- Plots -----------------
plt.figure(figsize=(20,20))
for i in range(0, len(nfft)):
  for j in range(0, len(wind)):
    for k in range(0, len(segsamp)):
      for o in range(0, len(overlap)):
        plt.subplot(subn,3,1)
        plt.plot(x)
        plt.title('True Signal')
        subp = 1 + subp
        anglez_x,bic_x,meansx,statistic_x= bicoher(x,nfft[i],wind[j],segsamp[k],overlap[o],3)
        plt.subplot(subn,3,2)
        plt.imshow(20*np.log10(abs(fftshift(bic_x))))
        plt.title('signal x with NFFT= {}'.format(nfft[i]) + ', Window= {}'.format(wind[j]) + ', segsamp= {}'.format(segsamp[k]) + ', overlap= {}'.format(overlap[o]))
        plt.subplot(subn,3,3)
        plt.hist(anglez_x,20)
        plt.subplots_adjust(hspace=0.5)
        plt.subplots_adjust(wspace=0.5)

plt.figure(figsize=(20,20))
for i in range(0, len(nfft)):
  for j in range(0, len(wind)):
    for k in range(0, len(segsamp)):
      for o in range(0, len(overlap)):
          plt.subplot(subn,3,4)
          plt.plot(X)
          plt.title('Fake Signal')
          anglez_X,bic_X,meansX,statistic_X= bicoher(X,nfft[i],wind[j],segsamp[k],overlap[o],3)
          plt.subplot(subn,3,5)
          plt.imshow(20*np.log10(abs(fftshift(bic_X))))
          plt.title('signal X with NFFT= {}'.format(nfft[i]) + ', Window= {}'.format(wind[j]) + ', segsamp= {}'.format(segsamp[k]) + ', overlap= {}'.format(overlap[o]))
          plt.subplot(subn,3,6)
          plt.subplots_adjust(hspace=0.5)
          plt.subplots_adjust(wspace=0.5)
          plt.hist(anglez_X,20)

all_true_var_ang[1] = statistic_x[0]
all_true_var_bic[1] = statistic_x[1]
all_true_std_ang[1] = statistic_x[2]
all_true_std_bic[1] = statistic_x[3]
all_true_skew_ang[1] = statistic_x[4]
all_true_skew_bic[1] = statistic_x[5]
all_true_kurtosis_ang[1] = statistic_x[6]
all_true_kurtosis_bic[1] = statistic_x[7]

all_fake_var_ang[1] = statistic_X[0]
all_fake_var_bic[1] = statistic_X[1]
all_fake_std_ang[1] = statistic_X[2]
all_fake_std_bic[1] = statistic_X[3]
all_fake_skew_ang[1] = statistic_X[4]
all_fake_skew_bic[1] = statistic_X[5]
all_fake_kurtosis_ang[1] = statistic_X[6]
all_fake_kurtosis_bic[1] = statistic_X[7]

print('var_ang')
print('         x = ',statistic_x[0], 'X = ',statistic_X[0])
print('var_bic')
print('         x = ',statistic_x[1],  'X = ',statistic_X[1])
print('std_ang' )
print('         x = ',statistic_x[2],  'X = ',statistic_X[2])
print('std_bic')
print('         x = ',statistic_x[3], 'X = ',statistic_X[3])
print('skew_ang')
print('         x  = ',statistic_x[4], 'X = ',statistic_X[4])
print('skew_bic')
print('         x = ',statistic_x[5], 'X = ',statistic_X[5])
print('kurtosis_ang')
print('         x = ',statistic_x[6], 'X = ',statistic_X[6])
print('kurtosis_bic')
print('         x = ',statistic_x[7], 'X = ',statistic_X[7])

"""# **tanh**"""

X = np.tanh(x)

#nfft = [64, 128, 512, 1024,2048]  
#wind = ['hann', 'hamm']
#segsamp = [64,128,256,512]
#overlap  = [30,50,70]
nfft = [2048]  
wind = ['hann']
segsamp = [32]
overlap  = [50]
subn=2
subp=3
## ---------- Plots -----------------
plt.figure(figsize=(20,20))
for i in range(0, len(nfft)):
  for j in range(0, len(wind)):
    for k in range(0, len(segsamp)):
      for o in range(0, len(overlap)):
        plt.subplot(subn,3,1)
        plt.plot(x)
        plt.title('True Signal')
        subp = 1 + subp
        anglez_x,bic_x,meansx,statistic_x= bicoher(x,nfft[i],wind[j],segsamp[k],overlap[o],3)
        plt.subplot(subn,3,2)
        plt.imshow(20*np.log10(abs(fftshift(bic_x))))
        plt.title('signal x with NFFT= {}'.format(nfft[i]) + ', Window= {}'.format(wind[j]) + ', segsamp= {}'.format(segsamp[k]) + ', overlap= {}'.format(overlap[o]))
        plt.subplot(subn,3,3)
        plt.hist(anglez_x,20)
        plt.subplots_adjust(hspace=0.5)
        plt.subplots_adjust(wspace=0.5)

plt.figure(figsize=(20,20))
for i in range(0, len(nfft)):
  for j in range(0, len(wind)):
    for k in range(0, len(segsamp)):
      for o in range(0, len(overlap)):
          plt.subplot(subn,3,4)
          plt.plot(X)
          plt.title('Fake Signal')
          anglez_X,bic_x,meansX,statistic_X= bicoher(X,nfft[i],wind[j],segsamp[k],overlap[o],3)
          plt.subplot(subn,3,5)
          plt.imshow(20*np.log10(abs(fftshift(bic_x))))
          plt.title('signal X with NFFT= {}'.format(nfft[i]) + ', Window= {}'.format(wind[j]) + ', segsamp= {}'.format(segsamp[k]) + ', overlap= {}'.format(overlap[o]))
          plt.subplot(subn,3,6)
          plt.subplots_adjust(hspace=0.5)
          plt.subplots_adjust(wspace=0.5)
          plt.hist(anglez_X,20)

all_true_var_ang[2] = statistic_x[0]
all_true_var_bic[2] = statistic_x[1]
all_true_std_ang[2] = statistic_x[2]
all_true_std_bic[2] = statistic_x[3]
all_true_skew_ang[2] = statistic_x[4]
all_true_skew_bic[2] = statistic_x[5]
all_true_kurtosis_ang[2] = statistic_x[6]
all_true_kurtosis_bic[2] = statistic_x[7]

all_fake_var_ang[2] = statistic_X[0]
all_fake_var_bic[2] = statistic_X[1]
all_fake_std_ang[2] = statistic_X[2]
all_fake_std_bic[2] = statistic_X[3]
all_fake_skew_ang[2] = statistic_X[4]
all_fake_skew_bic[2] = statistic_X[5]
all_fake_kurtosis_ang[2] = statistic_X[6]
all_fake_kurtosis_bic[2] = statistic_X[7]

print('var_ang')
print('         x = ',statistic_x[0], 'X = ',statistic_X[0])
print('var_bic')
print('         x = ',statistic_x[1],  'X = ',statistic_X[1])
print('std_ang' )
print('         x = ',statistic_x[2],  'X = ',statistic_X[2])
print('std_bic')
print('         x = ',statistic_x[3], 'X = ',statistic_X[3])
print('skew_ang')
print('         x  = ',statistic_x[4], 'X = ',statistic_X[4])
print('skew_bic')
print('         x = ',statistic_x[5], 'X = ',statistic_X[5])
print('kurtosis_ang')
print('         x = ',statistic_x[6], 'X = ',statistic_X[6])
print('kurtosis_bic')
print('         x = ',statistic_x[7], 'X = ',statistic_X[7])

"""# **Fearture Extractor**"""

!apt-get install subversion    #this is to be able to import an audio folder form a github depository

"""# TRUE"""

!svn checkout https://github.com/enzojam/true.git # import the audio folder

truelist = [str(file) for file in Path('/content/true.git/trunk/').glob('*.wav')] # are taking all the files in the path directory that start with kick_ and have and mp3 extension and for each one we get the string to the path

truelist  # they are basically lists of paths

true_signals = list (librosa.load(p)[0] for p in truelist) #we create a list in which each component is the correspong wav file anche we sotre it in the list

"""# FAKE"""

!svn checkout https://github.com/enzojam/fake.git

fakelist = [str(file) for file in Path('/content/fake.git/trunk/').glob('*.wav')]
fakelist

# we store alle the features in 1 matrix
# feature_table = np.vstack((kick_features,snare_features))
#print(feature_table.shape) # we have concatenated the 2 features

files_table= truelist+ fakelist

fake_signals = list (librosa.load(p)[0] for p in fakelist)

"""# ***Features***"""

x = true_signals[7]
X = fake_signals[13]
# ---------------- Params
#	[bic,waxis] = bicoher (y,  nfft, wind, segsamp, overlap)

#nfft = [64, 128, 512, 1024,2048]  
#wind = ['hann', 'hamm']
#segsamp = [64,128,256,512]
#overlap  = [30,50,70]
nfft = [2048]  
wind = ['hann']
segsamp = [32]
overlap  = [50]
subn=2
subp=3
## ---------- Plots -----------------
plt.figure(figsize=(20,20))
for i in range(0, len(nfft)):
  for j in range(0, len(wind)):
    for k in range(0, len(segsamp)):
      for o in range(0, len(overlap)):
        plt.subplot(subn,3,1)
        plt.plot(x)
        plt.title('True Signal')
        subp = 1 + subp
        anglez_x,bic_x,meansx,statistic_x= bicoher(x,nfft[i],wind[j],segsamp[k],overlap[o],3)
        plt.subplot(subn,3,2)
        plt.imshow(20*np.log10(abs(fftshift(bic_x))))
        plt.title('signal x with NFFT= {}'.format(nfft[i]) + ', Window= {}'.format(wind[j]) + ', segsamp= {}'.format(segsamp[k]) + ', overlap= {}'.format(overlap[o]))
        plt.subplot(subn,3,3)
        plt.hist(anglez_x,20)
        plt.subplots_adjust(hspace=0.5)
        plt.subplots_adjust(wspace=0.5)

plt.figure(figsize=(20,20))
for i in range(0, len(nfft)):
  for j in range(0, len(wind)):
    for k in range(0, len(segsamp)):
      for o in range(0, len(overlap)):
          plt.subplot(subn,3,4)
          plt.plot(X)
          plt.title('Fake Signal')
          anglez_X,bic_x,meansX,statistic_X= bicoher(X,nfft[i],wind[j],segsamp[k],overlap[o],3)
          plt.subplot(subn,3,5)
          plt.imshow(20*np.log10(abs(fftshift(bic_x))))
          plt.title('signal X with NFFT= {}'.format(nfft[i]) + ', Window= {}'.format(wind[j]) + ', segsamp= {}'.format(segsamp[k]) + ', overlap= {}'.format(overlap[o]))
          plt.subplot(subn,3,6)
          plt.subplots_adjust(hspace=0.5)
          plt.subplots_adjust(wspace=0.5)
          plt.hist(anglez_X,20)

all_true_var_ang[3] = statistic_x[0]
all_true_var_bic[3] = statistic_x[1]
all_true_std_ang[3] = statistic_x[2]
all_true_std_bic[3] = statistic_x[3]
all_true_skew_ang[3] = statistic_x[4]
all_true_skew_bic[3] = statistic_x[5]
all_true_kurtosis_ang[3] = statistic_x[6]
all_true_kurtosis_bic[3] = statistic_x[7]

all_fake_var_ang[3] = statistic_X[0]
all_fake_var_bic[3] = statistic_X[1]
all_fake_std_ang[3] = statistic_X[2]
all_fake_std_bic[3] = statistic_X[3]
all_fake_skew_ang[3] = statistic_X[4]
all_fake_skew_bic[3] = statistic_X[5]
all_fake_kurtosis_ang[3] = statistic_X[6]
all_fake_kurtosis_bic[3] = statistic_X[7]

X = fake_signals[13]
ipd.display(ipd.Audio(X, rate=22050))         # we use idp.Audio to listen to each note

x = true_signals[7]
ipd.display(ipd.Audio(x, rate=22050))         # we use idp.Audio to listen to each note

plt.figure(figsize=(20,6))
plt.subplot(1,3,3)
plt.scatter(-10*np.log10(all_fake_var_bic[3]),-10*np.log10(all_fake_std_bic[3]),c='r',marker = '*')
plt.scatter(-10*np.log10(all_true_var_bic[3]),-10*np.log10(all_true_std_bic[3]),c='m',marker = 'd')
plt.title('Mixed data')
plt.xlabel('var Bic')
plt.ylabel('STD Bic')
plt.legend((' fake','True'))

print('var_ang')
print('x = ',statistic_x[0], 'X = ',statistic_X[0])
print('var_bic')
print('x = ',statistic_x[1],  'X = ',statistic_X[1])
print('std_ang' )
print('x = ',statistic_x[2],  'X = ',statistic_X[2])
print('std_bic')
print('x = ',statistic_x[3], 'X = ',statistic_X[3])
print('skew_ang')
print('x  = ',statistic_x[4], 'X = ',statistic_X[4])
print('skew_bic')
print('x = ',statistic_x[5], 'X = ',statistic_X[5])
print('kurtosis_ang')
print('x = ',statistic_x[6], 'X = ',statistic_X[6])
print('kurtosis_bic')
print('x = ',statistic_x[7], 'X = ',statistic_X[7])

"""# **PLOT**"""

plt.figure(figsize=(6,20))
plt.subplot(3,1,1)
plt.scatter(10*np.log10(all_true_var_ang[0]),10*np.log10(all_true_var_bic[0]),c='r',marker='*')
plt.scatter(10*np.log10(all_true_var_ang[1]),10*np.log10(all_true_var_bic[1]),c='b',marker='1')
plt.scatter(10*np.log10(all_true_var_ang[2]),10*np.log10(all_true_var_bic[2]),c='g',marker='x')
plt.scatter(10*np.log10(all_true_var_ang[3]),10*np.log10(all_true_var_bic[3]),c='y',marker='d')
plt.title('Truth data')
plt.xlabel('Var Ang')
plt.ylabel('Var Bic')
plt.legend(('x^2','x/sqrt(1+x2)','tanh','wavnet'))

plt.figure(figsize=(6,20))
plt.subplot(3,1,2)
plt.scatter(10*np.log10(all_fake_var_ang[0]),10*np.log10(all_fake_var_bic[0]),c='r',marker='*')
plt.scatter(10*np.log10(all_fake_var_ang[1]),10*np.log10(all_fake_var_bic[1]),c='b',marker='1')
plt.scatter(10*np.log10(all_fake_var_ang[2]),10*np.log10(all_fake_var_bic[2]),c='g',marker='x')
plt.scatter(10*np.log10(all_fake_var_ang[3]),10*np.log10(all_fake_var_bic[3]),c='y',marker='d')
plt.title('Fake data')
plt.xlabel('Var Ang')
plt.ylabel('Var Bic')
plt.legend(('x^2','x/sqrt(1+x2)','tanh','wavnet'))


plt.figure(figsize=(6,20))
plt.subplot(3,1,3)
plt.scatter(10*np.log10(all_fake_var_ang[0]),10*np.log10(all_fake_var_bic[0]),c='r',marker='*')
plt.scatter(10*np.log10(all_fake_var_ang[1]),10*np.log10(all_fake_var_bic[1]),c='b',marker='1')
plt.scatter(10*np.log10(all_fake_var_ang[2]),10*np.log10(all_fake_var_bic[2]),c='g',marker='x')
plt.scatter(10*np.log10(all_fake_var_ang[3]),10*np.log10(all_fake_var_bic[3]),c='y',marker='d')
plt.scatter(10*np.log10(all_true_var_ang[0]),10*np.log10(all_true_var_bic[0]),c='m',marker='*')
plt.scatter(10*np.log10(all_true_var_ang[1]),10*np.log10(all_true_var_bic[1]),c='m',marker='1')
plt.scatter(10*np.log10(all_true_var_ang[2]),10*np.log10(all_true_var_bic[2]),c='m',marker='x')
plt.scatter(10*np.log10(all_true_var_ang[3]),10*np.log10(all_true_var_bic[3]),c='m',marker='d')
plt.title('Mixed data')
plt.xlabel('Var Ang')
plt.ylabel('Var Bic')
plt.legend((' fake x^2','fake x/sqrt(1+x2)','fake tanh','fake wavnet','x^2','x/sqrt(1+x2)','tanh','wavnet'))

plt.figure(figsize=(20,6))
plt.subplot(1,3,1)
plt.scatter(all_true_std_ang[0],10*np.log10(all_true_std_bic[0]),c='r',marker = '*')
plt.scatter(all_true_std_ang[1],10*np.log10(all_true_std_bic[1]),c='b',marker = '1')
plt.scatter(all_true_std_ang[2],10*np.log10(all_true_std_bic[2]),c='g',marker = 'x')
plt.scatter(all_true_std_ang[3],10*np.log10(all_true_std_bic[3]),c='y',marker = 'd')
plt.title('Truth data')
plt.xlabel('STD Ang')
plt.ylabel('STD Bic')
plt.legend(('x^2','x/sqrt(1+x2)','tanh','wavnet'))

plt.figure(figsize=(20,6))
plt.subplot(1,3,2)
plt.scatter(all_fake_std_ang[0],10*np.log10(all_fake_std_bic[0]),c='r',marker = '*')
plt.scatter(all_fake_std_ang[1],10*np.log10(all_fake_std_bic[1]),c='b',marker = '1')
plt.scatter(all_fake_std_ang[2],10*np.log10(all_fake_std_bic[2]),c='g',marker = 'x')
plt.scatter(all_fake_std_ang[3],10*np.log10(all_fake_std_bic[3]),c='y',marker = 'd')
plt.title('Fake data')
plt.xlabel('STD Ang')
plt.ylabel('STD Bic')
plt.legend(('x^2','x/sqrt(1+x2)','tanh','wavnet'))

plt.figure(figsize=(20,6))
plt.subplot(1,3,3)
plt.scatter(all_fake_std_ang[0],10*np.log10(all_fake_std_bic[0]),c='r',marker = '*')
plt.scatter(all_fake_std_ang[1],10*np.log10(all_fake_std_bic[1]),c='b',marker = '1')
plt.scatter(all_fake_std_ang[2],10*np.log10(all_fake_std_bic[2]),c='g',marker = 'x')
plt.scatter(all_fake_std_ang[3],10*np.log10(all_fake_std_bic[3]),c='y',marker = 'd')
plt.scatter(all_true_std_ang[0],10*np.log10(all_true_std_bic[0]),c='m',marker = '*')
plt.scatter(all_true_std_ang[1],10*np.log10(all_true_std_bic[1]),c='m',marker = '1')
plt.scatter(all_true_std_ang[2],10*np.log10(all_true_std_bic[2]),c='m',marker = 'x')
plt.scatter(all_true_std_ang[3],10*np.log10(all_true_std_bic[3]),c='m',marker = 'd')
plt.title('Mixed data')
plt.xlabel('STD Ang')
plt.ylabel('STD Bic')
plt.legend((' fake x^2','fake x/sqrt(1+x2)','fake tanh','fake wavnet','x^2','x/sqrt(1+x2)','tanh','wavnet'))

plt.figure(figsize=(20,6))
plt.subplot(1,3,1)
plt.scatter(all_true_skew_ang[0],all_true_skew_bic[0],c='r')
plt.scatter(all_true_skew_ang[1],all_true_skew_bic[1],c='b')
plt.scatter(all_true_skew_ang[2],all_true_skew_bic[2],c='g')
plt.scatter(all_true_skew_ang[3],all_true_skew_bic[3],c='y')
plt.title('Truth data')
plt.xlabel('Skew Ang')
plt.ylabel('Skew Bic')
plt.legend(('x^2','x/sqrt(1+x2)','tanh','wavnet'))

plt.figure(figsize=(20,6))
plt.subplot(1,3,2)
plt.scatter(all_fake_skew_ang[0],all_fake_skew_bic[0],c='r')
plt.scatter(all_fake_skew_ang[1],all_fake_skew_bic[1],c='b')
plt.scatter(all_fake_skew_ang[2],all_fake_skew_bic[2],c='g')
plt.scatter(all_fake_skew_ang[3],all_fake_skew_bic[3],c='y')
plt.title('Fake data')
plt.xlabel('Skew Ang')
plt.ylabel('Skew Bic')
plt.legend(('x^2','x/sqrt(1+x2)','tanh','wavnet'))

plt.figure(figsize=(20,6))
plt.subplot(1,3,3)
plt.scatter(all_true_skew_ang[0],all_true_skew_bic[0],c='m',marker ='*')
plt.scatter(all_true_skew_ang[1],all_true_skew_bic[1],c='m',marker ='1')
plt.scatter(all_true_skew_ang[2],all_true_skew_bic[2],c='m',marker ='x')
plt.scatter(all_true_skew_ang[3],all_true_skew_bic[3],c='m',marker ='d')
plt.scatter(all_fake_skew_ang[0],all_fake_skew_bic[0],c='r',marker ='*')
plt.scatter(all_fake_skew_ang[1],all_fake_skew_bic[1],c='b',marker ='1')
plt.scatter(all_fake_skew_ang[2],all_fake_skew_bic[2],c='g',marker ='x')
plt.scatter(all_fake_skew_ang[3],all_fake_skew_bic[3],c='y',marker ='d')
plt.title('Mixed data')
plt.xlabel('Skew Ang')
plt.ylabel('Skew Bic')
plt.legend(('x^2','x/sqrt(1+x2)','tanh','wavnet',' fake x^2','fake x/sqrt(1+x2)','fake tanh','fake wavnet'))

plt.figure(figsize=(20,6))
plt.subplot(1,3,1)
plt.scatter(all_true_kurtosis_ang[0],all_true_kurtosis_bic[0],c='r',marker = '*')
plt.scatter(all_true_kurtosis_ang[1],all_true_kurtosis_bic[1],c='b',marker = '1')
plt.scatter(all_true_kurtosis_ang[2],all_true_kurtosis_bic[2],c='g',marker = 'x')
plt.scatter(all_true_kurtosis_ang[3],all_true_kurtosis_bic[3],c='y',marker = 'd')
plt.title('Truth data')
plt.xlabel('Kurtosis Ang')
plt.ylabel('Kurtosis Bic')
plt.legend(('x^2','x/sqrt(1+x2)','tanh','wavnet'))

plt.figure(figsize=(20,6))
plt.subplot(1,3,2)
plt.scatter(all_fake_kurtosis_ang[0],all_fake_kurtosis_bic[0],c='r',marker = '*')
plt.scatter(all_fake_kurtosis_ang[1],all_fake_kurtosis_bic[1],c='b',marker = '1')
plt.scatter(all_fake_kurtosis_ang[2],all_fake_kurtosis_bic[2],c='g',marker = 'x')
plt.scatter(all_fake_kurtosis_ang[3],all_fake_kurtosis_bic[3],c='y', marker = 'd')
plt.title('Fake data')
plt.xlabel('Kurtosis Ang')
plt.ylabel('Kurtosis Bic')
plt.legend(('x^2','x/sqrt(1+x2)','tanh','wavnet'))

plt.figure(figsize=(20,6))
plt.subplot(1,3,3)
plt.scatter(all_true_kurtosis_ang[0],all_true_kurtosis_bic[0],c='m',marker = '*')
plt.scatter(all_true_kurtosis_ang[1],all_true_kurtosis_bic[1],c='m',marker = '1')
plt.scatter(all_true_kurtosis_ang[2],all_true_kurtosis_bic[2],c='m',marker = 'x')
plt.scatter(all_true_kurtosis_ang[3],all_true_kurtosis_bic[3],c='m',marker = 'd')
plt.scatter(all_fake_kurtosis_ang[0],all_fake_kurtosis_bic[0],c='r',marker = '*')
plt.scatter(all_fake_kurtosis_ang[1],all_fake_kurtosis_bic[1],c='b',marker = '1')
plt.scatter(all_fake_kurtosis_ang[2],all_fake_kurtosis_bic[2],c='g',marker = 'x')
plt.scatter(all_fake_kurtosis_ang[3],all_fake_kurtosis_bic[3],c='y',marker = 'd')
plt.title('mixed data')
plt.xlabel('Kurtosis Ang')
plt.ylabel('Kurtosis Bic')
plt.legend(('x^2','x/sqrt(1+x2)','tanh','wavnet',' fake x^2','fake x/sqrt(1+x2)','fake tanh','fake wavnet'))